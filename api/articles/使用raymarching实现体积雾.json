{"title":"使用raymarching实现体积雾","slug":"使用raymarching实现体积雾","date":"2020-07-15T08:28:56.000Z","updated":"2020-07-16T07:59:57.315Z","comments":true,"path":"api/articles/使用raymarching实现体积雾.json","photos":[],"link":"","excerpt":null,"covers":["../image/体积雾/RayMarching.png","../image/体积雾/体积雾.png"],"content":"<p>前段时间在学习rayMarching技术，看到许多大佬搞的体积雾。我也做了一个简单的。</p>\n<h1 id=\"RayMarching原理\"><a href=\"#RayMarching原理\" class=\"headerlink\" title=\"RayMarching原理\"></a>RayMarching原理</h1><p>RayMarching（光线步进）严格上来说应该是后期的一种。<br>一个简单的实现是在屏幕上绘制球体：从光线原点射出光线，先以原点为中心调用一次距离函数，计算出此点到球形表面的最短距离。如果小于设置好的误差值，就视为接触到物体，返回距离值。如果判断没接触到，则沿着光线向量前进刚刚计算出的距离值得到新的圆心继续求距离，直到判定为接触物体。如果前进步数过多，超出设定最高步数或者前进距离超出最远距离，就视为无法接触物体。<br><img src=\"../image/体积雾/RayMarching.png\" alt=\"RayMarching\"><br>如果要像上图那样检测多个物体，就可以分别计算原点到多个物体表面的距离，然后取最小值，就能同时检测多个物体。如果取最大值则是将图形取并集，再合理地对距离值取负值，就能完美地完成几何体的布尔运算。你也可以在<a href=\"https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\" target=\"_blank\" rel=\"noopener\">这个网站</a>中找到许多几何体的距离函数和一些有趣的融合算法。<br>如果我们对每个像素都进行上述的步进操作，就能得到物体的深度值，也就能开始着色了。法线的计算是根据计算附近像素点的深度值得出。如果想要仅仅显示几何体，做到这一步就能按照传统的光照方案计算出图案，值得注意的是，由于RayMarching技术是后期处理，因此要考虑到如何与背景图像进行融合。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float3 getNormal(float3 p)//近似计算出法线</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">float2 offset = float2(0.001f,0.0f);</span><br><span class=\"line\">//float d = getDist(p);</span><br><span class=\"line\">float3 n= float3(</span><br><span class=\"line\">    getDist(p+offset.xyy)-getDist(p-offset.xyy),</span><br><span class=\"line\">    getDist(p+offset.yxy)-getDist(p-offset.yxy),</span><br><span class=\"line\">    getDist(p+offset.yyx)-getDist(p-offset.yyx)</span><br><span class=\"line\">);</span><br><span class=\"line\">return normalize(n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"简单体积雾运算\"><a href=\"#简单体积雾运算\" class=\"headerlink\" title=\"简单体积雾运算\"></a>简单体积雾运算</h1><p>接下来就可以按照乐乐老师的<a href=\"https://www.shadertoy.com/view/Xsd3R2\" target=\"_blank\" rel=\"noopener\">shadertoy项目</a>的体积雾运算再次进行颜色绘制。这是一个简单的体积雾颜色绘制。基本原理就是在计算好的几何体内，按照几乎相同的步长进行步进操作，按照一定的噪声算法对像素增加不透明度，并且按照当前点到球心的距离进行着色。很显然。这并不是一个基于物理的体积雾着色，但是效果非常不错。我在引入着色代码后进行了一定的更改：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float3 raymarchingCloud(float3 ro, float3 rd, float t,float3 backCol,float depth)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\tfloat4 sum = float4(0.0,0.0,0.0,0.0);</span><br><span class=\"line\">\tfloat3 pos = ro + rd * t;</span><br><span class=\"line\">\tfor (int i = 0; i &lt; 30; i++) &#123;</span><br><span class=\"line\">\t\tfloat4 col;</span><br><span class=\"line\">\t\tfloat radiusSum = 0;</span><br><span class=\"line\">\t\tfor(int i=0; i&lt;_SphereNum; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tradiusSum += _SpherePositions[i].w;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tradiusSum /= _SphereNum;</span><br><span class=\"line\">\t\tfloat dist = radiusSum+_Fog*getDist(pos);</span><br><span class=\"line\">\t\tif ( sum.a &gt; 0.99 || t&gt;depth ) continue;</span><br><span class=\"line\">\t\tfloat den = density(pos, dist);</span><br><span class=\"line\">\t\tcol = float4(color(den, dist), den*_FogDensity);</span><br><span class=\"line\">\t\tcol.rgb *= col.a;</span><br><span class=\"line\">\t\tsum = sum + col*(1.0 - sum.a); </span><br><span class=\"line\">\t\tt += max(0.05, 0.02 * t);</span><br><span class=\"line\">\t\tpos = ro + rd * t;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsum = clamp(sum, 0.0, 1.0);</span><br><span class=\"line\">\tbackCol = lerp(backCol, sum.xyz, sum.a);</span><br><span class=\"line\">\treturn backCol;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我将原算法中对当前点到球心的距离算法改为了到几何体表明的距离。这样就能兼容不同几何形状的烟雾，甚至多个烟雾效果。同时我也增加了两个能够管理烟雾浓度的参数，方便使用。<br><img src=\"../image/体积雾/体积雾.png\" alt=\"体积雾\"><br>上面就算体积雾的效果。效果优点：<br>1简单快速，占用较少<br>2深度检测，能较好的与环境融合<br>3支持多个烟雾<br>4效果优秀<br>5使用Object和脚本进行烟雾管理<br>缺点：<br>1并非基于物理，并不能很好的与光照进行交互<br>2z轴的烟雾融合并不算很好<br>为了解决以上两个问题，还准备找个时间做个基于物理体积雾系统。</p>\n","categories":[],"tags":[]}